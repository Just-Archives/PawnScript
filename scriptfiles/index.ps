/*
*
* PawnScript
* Testing Entry point
*
* (c) Brace Inc.
*/

using console

int myfunc() public
{
	console.println.log("test")
	return int 238
}

new[int]myretref=456

console.println.log("myretref is {myretref}")

user.myfunc() myretref

console.println.log("myretref is {myretref}")

using console for
{
	console.println.log("lol")
}
console.println.log("lol again")

void myfunc2() public
{
	using console for
	{
		console.println.log("myfunc2 called")
	}
	console.println("SHOULD NOT BE SHOWN RN")
}

user.myfunc2

////////////////////////////
#restemp
using data
myretref=327
console.println.log("myretref is {myretref}")

@export
	this->typename=int
	this->from=myretref
	this->to=pspdmftest
data.persistent

myretref=0
console.println.log("myretref is {myretref}")

@import
	this->typename=int
	this->from=pspdmftest
	this->to=myretref
data.persistent

console.println.log("myretref is {myretref}")

////////////////////////////
new[str]mystring="str1"
console.println.log("mystring is {mystring}")

@export
	this->typename=str
	this->from=mystring
	this->to=pspdmftest2
data.persistent.export

mystring="str2"
console.println.log("mystring is {mystring}")

@import
	this->typename=str
	this->from=pspdmftest2
	this->to=mystring
data.persistent.import

console.println.log("mystring is {mystring}")

requires samp
{
	using @global for
	{
		@global.setserverattrib
		@global.setserverattrib.hostname("My Server")
	}
	@global.setserverattrib
}

@global.setserverattrib

void myPrivateFunc() private
{
	console.println("my private func works")
}

user.myPrivateFunc

@extern
	this->struct=default
void main() public
{
	console.println("Main func called")
}

@extern
	this->struct=callback
int @onserverinit() public
{
	console.println.log("@onserverinit called!")
	void inlinefunc() inline
	<
		console.println.log("INLINE WORKS!")
	>
	user.inlinefunc

	console.println.log("end")
	return int 1
}

/////
console.println.log("OOP")
namespace test
{
	class ANOTHERTEST
	{
		new[int]myvar=7
	}
}

object MyObj=test::ANOTHERTEST
console.println.log("{MyObj.myvar}")
MyObj.myvar=24
console.println.log("{MyObj.myvar}")

using namespace test
{
	enum MyEnum
	{
		ting1=4
		ting2=7
		ting3=85
	}

	enum MyEnum2
	{
		q=0
		w
		z
		e=85
		r=86
	}

	void myNameSpaceFunc() private
	{
		console.println.log("myNameSpaceFunc works")
	}
}


user.test::myNameSpaceFunc()

console.rawout.log(test::MyEnum.ting3)

console.rawout.log(test::MyEnum2.q)
console.rawout.log(test::MyEnum2.w)
console.rawout.log(test::MyEnum2.z)
console.rawout.log(test::MyEnum2.e)
console.rawout.log(test::MyEnum2.r)

console.rawout.log(test::MyEnum.ting1)
console.rawout.log(test::MyEnum.ting2)
console.rawout.log(test::MyEnum.ting3)

console.rawout.log(test::MyEnum2.r-test::MyEnum.ting1); //we should see 82

new[byte]foobyte=743; // we will see 0
console.println("{foobyte}")
foobyte=-4847; // we will see 0
console.println("{foobyte}")
foobyte=128; // we will see 0
console.println("{foobyte}")
foobyte=127; // we will see 127
console.println("{foobyte}")

@task
	this->interval=4000
	this->repeat=true
void myTask() private
{
	new[int]process_speed=$system.speed
	console.println("Process speed: {process_speed} Hz")
	#undef:process_speed
}


////////////
new[byte]myNewByte1=0
new[byte]myNewbyte2=0
new[ptr]myFirstPointer=addressof?myNewByte1
myFirstPointer=56
myFirstPointer=addressof?myNewbyte2
myFirstPointer=-53
console.println.log("myNewByte1 is {myNewByte1} and myNewbyte2 is {myNewbyte2}")

using namespace test
{
	new[ptr]myPtr=addressof?myNewByte1
}

test::myPtr=-9
test::myPtr=addressof?myNewbyte2
test::myPtr=457
console.println.log("myNewByte1 is {myNewByte1} and myNewbyte2 is {myNewbyte2}")
///////////
void ChangeVarTo38(address) private
{
	test::myPtr=address@ChangeVarTo38
	test::myPtr=38
}
user.ChangeVarTo38(addressof?myNewbyte2)
console.println.log("myNewbyte2 is now {myNewbyte2}")
////////////////////
new[double]myDecimal=83.45
console.println.log("myDecimal is {myDecimal}")
test::myPtr=addressof?myDecimal
test::myPtr=74.5
console.println.log("myDecimal is now {myDecimal}")
new[str]myText="shit"
console.println.log("myText is {myText}")
test::myPtr=addressof?myText
test::myPtr="poop"
console.println.log("myText is now {myText}")
/////////////
switch myNewbyte2
case 43
{
	console.println.log("crap's 43")
}
case 38
{
	console.println.log("crap's 38")
	namespace nestedNSpace
	{
		new[int]LOL=83
	}
	console.println.log("nestedNSpace::LOL is {nestedNSpace::LOL}")
}
case 3
{
	console.println.log("crap's 43")
}
////


int myYieldFunc() private
{
	return int 3
}


user.myYieldFunc() nestedNSpace::LOL
console.println.log("nestedNSpace::LOL is now {nestedNSpace::LOL}") nestedNSpace::LOL


console.println.log("nestedNSpace::LOL is now {nestedNSpace::LOL}")

#restemp


class Human
{
	new[int]age=8
}

object me=Human
console.println.log("me.age is now {me.age}")
user.myYieldFunc() me.age
console.println.log("me.age is now {me.age}") me.age


console.println.log("me.age is now {me.age}")
#restemp

void myQuietFunc(num,text) private
{
	static[int]PortableStatic=763
	console.println(text@myQuietFunc)
	console.println("num@myQuietFunc is {num@myQuietFunc}")
}

int myYieldFunc2() private
{
	static[byte]StaticByteTest=873
	console.println.log("StaticByteTest is now {StaticByteTest}")
	StaticByteTest=-333
	console.println.log("StaticByteTest is now {StaticByteTest}")
	StaticByteTest=7
	console.println.log("StaticByteTest is now {StaticByteTest}")

	[quiet]
	user.myQuietFunc(2,"test print yo wtf")

	console.println.log("StaticByteTest is now {StaticByteTest}")
	console.println.log("PortableStatic is now {PortableStatic}")
	return int 1
}

user.myYieldFunc2