/*
*
* PawnScript
* Testing Entry point
*
* (c) Brace Inc.
*/


#include:stdlib;

#pragma:reqref,false; // Disable for good.

#pragma:allspc,true;
#pragma:warnings,default;

const*new.bool,DEBUG_OPTION=false;

#pragma:debug,DEBUG_OPTION;
#pragma:ctrlchar,'ยง';

#include:test;

system.rem("Basic println example.");
console.println("Hual is a fucking bitch");

void testfunc() public;
{
	console.println("testfunc works.");
	console.println("testfunc works.");
}

void NewTestFunc() public;
{
	console.println("OH YEAH MAN");
}

user.testfunc;
user.NewTestFunc;

system.rem("=================== NATIVES ===================");

system.rem("a_samp for D++");

const*new.int,MAX_PLAYERS=1000;
const*new.int,MAX_ACTORS=1000;
const*new.int,MAX_VEHICLES=2000;

samp.SetGameModeText("d++ test");
samp.SetMaxPlayers(MAX_PLAYERS);

system.rem("===================FUNCS===================");

str testFunc() public;
{
	console.println("testFunc was called.");
	// We CANNOT return strings as literals if they contain spaces
	// Return a static variable instead.
	static*new.str,returnstr="testFunc returned this."
	return returnstr
}

const*new.str,LMAO="Lmao";

str disableDebug() public;
{
	console.println("Debug disabled");
	return LMAO
}

console.println(testFunc);
console.println(disableDebug);

system.rem("===================CALLBACKS===================");


extern&struct*public.main;
{
	console.println("Hello World from main");
	return int 1
}

extern&struct*public.OnGameModeInit;
{
	console.println("OnGameModeInit works");
	return int 1
	console.println("RETURN FAILED");
	console.println("OMG LOL HAHAHAH RETURN DOES NOT WORK");
}

@hook;
int OnGameModeInit() public;
{
	console.println("OnGameModeInit works twice!!!");
	return 1
}

extern&struct*public.OnGameModeExit;
{
	console.println("OnGameModeExit works");
	return bool true
}

void syntaxtextfunc(text, num) public;{
	std::writeln(text@syntaxtextfunc);
	std::writec(num@syntaxtextfunc);
}

user.syntaxtextfunc("Hey", 'c');

@task
	this->interval=10000
	this->repeat=false
void nonrepeatingtimer() public
{
	std::writeln("nonrepeatingtimer works!")
}

new.int,testvar=1==1;
console.println.log("1==1: {testvar}");
testvar=1!=1;
console.println.log("1!=1: {testvar}");
testvar=1>=1;
console.println.log("1>=1: {testvar}");
testvar=1<=2;
console.println.log("1<=2: {testvar}");
testvar=1<2;
console.println.log("1<2: {testvar}");
testvar=1>2;
console.println.log("1>2: {testvar}");

testvar=5+5==11-1;
std::writeln("{testvar}");
testvar=5>4.9;
std::writeln("{testvar}");
testvar=5<5.1;
std::writeln("{testvar}");
testvar=3.14>3.15;
std::writeln("{testvar}");
testvar=234.4-200<=89+0.9;
std::writeln("{testvar}");

#undef:testvar;

namespace testnamespace
{
	class testclass
	{
		new.int,testinteger=1
	}
}

object,Obj=testnamespace::testclass
Obj.testinteger=13
std::writeln("{Obj.testinteger}")

#include:vars;
#include:math;
#include:class;
#include:args;
#include:discord;
#include:files;
#include:inline;
#include:tasks;
#include:struct;
#include:iter;
#include:data;
#include:enum;
#include:pawn;
#include:emit;
#include:trytest;
#include:consoletest;
#include:vector;