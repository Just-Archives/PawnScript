/*
*
* PawnScript
* Testing Entry point
*
* (c) Brace Inc.
*/

using console

int myfunc() public
{
	console.println.log("test")
	return int 238
}

new[int]myretref=456

console.println.log("myretref is {myretref}")

user.myfunc() myretref

console.println.log("myretref is {myretref}")

using console for
{
	console.println.log("lol")
}
console.println.log("lol again")

void myfunc2() public
{
	using console for
	{
		console.println.log("myfunc2 called")
	}
	console.println("SHOULD NOT BE SHOWN RN")
}

user.myfunc2

////////////////////////////
#restemp
using data
myretref=327
console.println.log("myretref is {myretref}")

@export
	this->typename=int
	this->from=myretref
	this->to="pspdmftest"
data.persistent

myretref=0
console.println.log("myretref is {myretref}")

@import
	this->typename=int
	this->from=pspdmftest
	this->to=myretref
data.persistent

console.println.log("myretref is {myretref}")

////////////////////////////
new[str]mystring="str1"
console.println.log("mystring is {mystring}")

@export
	this->typename=str
	this->from=mystring
	this->to=pspdmftest2
data.persistent.export

mystring="str2"
console.println.log("mystring is {mystring}")

@import
	this->typename=str
	this->from=pspdmftest2
	this->to=mystring
data.persistent.import

console.println.log("mystring is {mystring}")



exit

#include:stdlib;

#pragma:reqref,false; // Disable for good.

#pragma:allspc,true;
#pragma:warnings,default;

const[bool]DEBUG_OPTION=false

#pragma:debug,DEBUG_OPTION;
#pragma:ctrlchar,'ยง';

#include:test;

system.rem("Basic println example.");
console.println("Hual is a fucking bitch");

void testfunc() public
{
	console.println("testfunc works.");
	console.println("testfunc works.");
}

void NewTestFunc() public
{
	console.println("OH YEAH MAN");
}

user.testfunc;
user.NewTestFunc;

system.rem("=================== NATIVES ===================");

system.rem("a_samp for D++");

const[int]MAX_PLAYERS=1000;
const[int]MAX_ACTORS=1000;
const[int]MAX_VEHICLES=2000;

samp.SetGameModeText("d++ test");
samp.SetMaxPlayers(MAX_PLAYERS);

system.rem("===================FUNCS===================");

str testFunc() public;
{
	console.println("testFunc was called.");
	// We CANNOT return strings as literals if they contain spaces
	// Return a static variable instead.
	static[str]returnstr="testFunc returned this."
	return returnstr
}

const[str] LMAO = "Lmao"

str disableDebug() public;
{
	console.println("Debug disabled");
	return LMAO
}

console.println(testFunc);
console.println(disableDebug);

system.rem("===================CALLBACKS===================");


@extern
	this->struct=default
int main() public
{
	console.println("Hello World from main");
	return int 1
}

@extern
	this->struct=default
int OnGameModeInit() public
{
	console.println("OnGameModeInit works");
	return int 1
	console.println("RETURN FAILED");
	console.println("OMG LOL HAHAHAH RETURN DOES NOT WORK");
}

@hook;
int OnGameModeInit() public;
{
	console.println("OnGameModeInit works twice!!!");
	return 1
}


@extern
	this->struct=default
int OnGameModeExit() public
{
	console.println("OnGameModeExit works");
	return bool true
}

void syntaxtextfunc(text, num) public;{
	std::writeln(text@syntaxtextfunc);
	std::writec(num@syntaxtextfunc);
}

user.syntaxtextfunc("Hey", 'c');

@task
	this->interval=10000
	this->repeat=false
void nonrepeatingtimer() public
{
	std::writeln("nonrepeatingtimer works!")
}

new[int.short]testvar=1==1;
console.println.log("1==1: {testvar}");
testvar=1!=1;
console.println.log("1!=1: {testvar}");
testvar=1>=1;
console.println.log("1>=1: {testvar}");
testvar=1<=2;
console.println.log("1<=2: {testvar}");
testvar=1<2;
console.println.log("1<2: {testvar}");
testvar=1>2;
console.println.log("1>2: {testvar}");

testvar=5+5==11-1;
std::writeln("{testvar}");
testvar=5>4.9;
std::writeln("{testvar}");
testvar=5<5.1;
std::writeln("{testvar}");
testvar=3.14>3.15;
std::writeln("{testvar}");
testvar=234.4-200<=89+0.9;
std::writeln("{testvar}");

#undef:testvar;

namespace testnamespace
{
	class testclass
	{
		new[int]testinteger=1
	}
}

object Obj=testnamespace::testclass
Obj.testinteger=13
std::writeln("{Obj.testinteger}")

int MyTaskFuncTest() public 
{
	void myinlinefunc() inline
	<
		console.println.log("1 is equal to 1")
	>

	if.equ,1,1->user.myinlinefunc()
	return bool true
}

@task
	this->interval=1000
void MyTestTask() public
{
	user.MyTaskFuncTest()
}

std::writeln("data.ps still works?")

#include:vars;
#include:math;
#include:class;
#include:args;
#include:discord;
#include:files;
#include:inline;
#include:tasks;
#include:struct;
#include:iter;
#include:data;
#include:enum;
#include:pawn;
#include:emit;
#include:trytest;
#include:consoletest;
#include:vector;

system.ver()

files.createdir("MyNewDir")
system.cd("MyNewDir/")
files.createdir("lmao")
system.cd("lmao/")

files.open_for_write("testfile.omg")
files.write("wrote this nigga")
files.close

system.cd(".."); // Reset back to scriptfiles
files.createdir("MyNewDirAgain")

console.println.log("PawnScript is the best language ever")

// Graphics test
using graphics

graphics.cls
graphics.showpixel(43,2)
graphics.showpixel(6,6)
graphics.showpixel(73,100)
graphics.show